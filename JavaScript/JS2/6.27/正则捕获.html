<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//let str = 'jisuobuyu2018wushiyuren2019';
//    let reg = /\d+/;
//
//    console.log(reg.exec('jisuobuyu'));
//    console.log(reg.exec(str));
////=>LAST-INDEX不变导致了正则捕获的懒惰行
//    console.log(reg.lastIndex);     //=>0正则捕获时候，下一次在字符串中开始查找的索引
//    console.log(reg.exec(str));     //=>2018
//    reg.lastIndex = 27;//手动修改lastIndex不起作用
//    console.log(reg.lastIndex);     //0
//    console.log(reg.exec(str));     //=>2018


//let str = 'jisuobuyu2018wushiyuren2019aaaa2020bbbb2021';
//let reg = /\d+/g;
//
//console.log(reg.exec('jisuobuyu'));
////console.log(reg.exec(str));
////=>LAST-INDEX不变导致了正则捕获的懒惰行
//console.log(reg.lastIndex);     //=>0
//console.log(reg.exec(str));     //=>2018
//console.log(reg.lastIndex);     //=>27
//console.log(reg.exec(str));     //=>2019


//    RegExp.prototype.myExecAll = function (str){
//        //this.reg 当前操作的正则
//        //=》str：我们要捕获的字符串
//        //=》执行EXEC开始捕获，具体捕获多少次不定，但是一直到捕获不到内容(null)为止，期间把捕获到的内容存储到数组中即可
//        //=》为了防止出现死循环：我们检测一下正则是否加G，没有加G只把第一次捕获的结果返回即可
//        let result = [];
//        valAry = this.exec(str);
//        if(!this.global){
//            return this.exec(str);
//        }
//        while (valAry){
//            result.push(valAry[0]);
//            valAry = this.exec(str);
//        }
//        return result;
//    };
//console.log(reg.myExecAll(str));
//console.log(str.match(reg));

//let str = 'gibi2018laowang2019';
//let reg = /\d+/g;
//console.log(reg.exec(str)); //=>['2'];
//console.log(reg.exec(str)); //=>['2'];
//console.log(str.match(reg)); //=>['2'];
////        正则捕获还具备贪婪性： 每次匹配捕获的时候，
////        总是捕获到和正则匹配中最长的内容，
////       例如： '2' 符合 \d+ '2018' 也符合 \d+,    但是捕获的是最长的内容 '2018'...


//    let str = 'gebi2018laowang2019';
//    let reg = /\d+?/g;  //=>把问号放到量词元字符后面，
////        代表的就不是出现零次或者一次了，而且取消捕获的贪婪性
//console.log(reg.exec(str)); //=>['2'];
//console.log(reg.exec(str)); //=>['2'];
//console.log(str.match(reg)); //=>['2'];


    //?在正则中的作用
//      1.量词元字符：出现零次或者一次
//          /-?/让减号出现一次或者不出现
//      2.取消贪婪性


//    let str = 'gebi2018laowang2019';
//    let reg = /\d+/g;
//    console.log(reg.lastIndex); //0
//    console.log(reg.test(str)); //true  test也会捕获
//    console.log(reg.lastIndex); //8
//    console.log(reg.exec(str)); //2019

//let str = 'gebi2018';
//let reg = /\d+/g;
//if (reg.test(str)){
//    console.log(reg.lastIndex); //8 test捕获以后 lastIndex变为8
//    console.log(reg.exec(str)); //null
//}

//    let str = 'gebi2018';
//    let reg = /\d+/g;
//    console.log(reg.lastIndex); //0
//    console.log(reg.exec(str)); //2018
//    console.log(reg.lastIndex); //8
//    console.log(reg.exec('gebi2018laowang2019'));   //2019 lastIndex是公用的 被修改了


//$1
//    let str = 'gebi2018laowang2019';
//    let reg = /(\d+)/g;
//    console.log(reg.lastIndex);
//    console.log(reg.test(str));
//    console.log(RegExp.$1);

//let str = 'laowang{val:2018}laowang{val:2019}',
//    reg = /\{val:(\d+)\}/g;
//str = str.replace(reg,(...arg) => {
//      console.log(arg);
//      return 'AA';
// })
//console.log(str);

//时间字符串格式化
//    "2018/4/30 17:50:23"    => "04-30 17:50"

//    简单处理
//    let str = "2018/4/30 17:50:23",
//        ary = str.split(/(?:\/| |:)/g);
//    console.log(ary);
//    let [, month, day, hours, minutes] = ary,
//        result = `${month}-${day} ${hours}:${minutes}`;
//    console.log(result);

//    let str = "2018/4/30 17:50:23";
//    let ary = str.match(/\d+/g).map(item => {
//                return item < 10 ? '0' + item : item;
//    }); //=>MAP相当于FOR-EACH来讲多了返回值，函数中RETURN的是啥，
////    就是把当前数组中迭代的这一项替换成啥
//    console.log(ary);   //=>["2018","04","30","17","50","23"]

//    String.prototype.myFormatTime =
//        function (template = '{0}年{1}月{2}日 {3}时{4}分{5}秒') {
//            let ary = this.match(/\d+/g).map(item => (item < 10 ? '0' + item : item));
//            return template.replace(/\{(\d)\}/g, (...[, index]) => ary[index] || '00');
//        };
//    let str = "2018-4-30";
//    console.log(str.myFormatTime('{1}-{2} {3}:{4}'));

////    统计出现最多的字母和次数(两种方法)
//    var str = 'aafbbcddddeeeAAABBCCCC';
////    1.统计每个字母出现的次数 - 利用对象不重名的特征
////    把每个字符作为属性名存入对象中，得出次作为属性值
//    var obj = {};
//    for (var i = 0;i<str.length;i++){
//        var cur = str.charAt(i);
//        if(obj[cur]){
//            obj[cur]++;//次数应该累加1    obj[cur] = obj[cur]+1
//        }else{//第一次
//            obj[cur] = 1;
//        }
//    }
//    console.log(obj);
////2.找出次数最多的字母
////     假设法
//    var maxStr = "";//出现最多的字母
//    var max = 0;//出现最多的次数
//    for(var key in obj){
//        //obj[key]次数
//        if(obj[key]>max) {
//            max = obj[key];
//            maxStr = key;
//        }else if(obj[key] == max){   //"a,b" 8 相同次数的字母之间以逗号隔开
//            maxStr +="," + key;
//        }
//    }
//console.log(maxStr, max);

//    var str = "aafbbcddddeeebbcAAABBCCCC";
//    var ary = str.split("");
//    console.log(ary);
//    ary.sort(function(a,b){
//        return a.localeCompare(b);
//    });
//    str = ary.join("");
//    var reg = /(\w)\1*/g;//匹配相同的字母
//    var maxStr = "";
//    var max = 0;
//    str.replace(reg,function ($0,$1){
//        //$1   字母 $0.length 匹配字符出现的次数
//        if($0.length > max){
//            max = $0.length;
//            maxStr = $1;
//        }else if($0.length == max){
//            maxStr+=","+$1;
//        }
//    });
//    console.log(maxStr,max);



    //排除法
//    获取地址栏中的参数并放入对象中
        var str = "http://www.baidu.com?id=557131028857&name=feicui&age=8#teacher=yang";
        var reg = /([^?&#=]+)=([^?&#=]+)/g;
        var obj = {};
        str.replace(reg,function ($0,$1,$2){
            obj[$1] = $2;
        });
    console.log(obj);
</script>
</body>
</html>