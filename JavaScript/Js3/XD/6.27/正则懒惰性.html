<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <textarea name="" id="txt1" cols="30" rows="10"></textarea>
    <input type="button" value="过滤" id="btn">
    <textarea name="" id="txt2" cols="30" rows="10"></textarea>

    <script>
    // let str ='gebi2018laowang2019';
    // let reg = /\d+/g;  //后面的g是全局捕获的意思，如果是 /\d+/就只能捕获到2018.
    // console.log(reg.exec('gebilaowang')); //=>null
    // console.log(reg.exec(str));
    // console.log(reg.exec(str));
    // console.log(reg.exec(str));
    // //=>LAST-INDEX不变导致了正则捕获的懒惰性
    // console.log(reg.lastIndex); //=>0 正则捕获的时候
    // //下一次在字符串中开始查找的索引
    // console.log(reg.exec(str)); //=>['2018]
    // //reg.lastIndex=8; //手动修改lastIndexlastIndex不起作用
    // console.log(reg.lastIndex); //=>0
    // console.log(reg.exec(str));//=>['2018]



// let str = 'gebi2018laowang2019yangfan2020qihang2021wrwerewr'
// let reg = /\d+/g;
// RegExp.prototype.myExecAll = function(str){
//     //this:reg 当前操作的正则
//     //str：我们要捕获的字符串
//     //执行EXEC开始捕获，具体捕获多少次不定，但是一直捕获不到内容(null)为止，
//     //期间把捕获到的内容储存到数组中即可
//     //为了防止出现死循环，我们加测一下正则是否加G，没有加G只把第一次的捕获结果返回即可 
//     if(!this.global){
//         return this.exec(str);
//     }
//     let result= [],
//           valAry = this.exec(str);
//           while(valAry){
//                 result.push(valAry[0]);
//                 valAry = this.exec(str);
//           }
//           return result;
// };
// console.log(reg.myExecAll(str));
// console.log(str.match(reg));                




// let str = 'gibi{2018}laowang{2019}yangfan{2020}qihang{2021}';
// let reg = /\{(\d+)\}/g;
// console.log(reg.exec(str))
// console.log(str.match(reg))
//MATCH方法也有自己的局限性，在正则设置了G的情况下，
//基于MATCH不活的内容只有大正则匹配的，
//小分组的内容没有单独抽取出来(不设置G的情况下和执行EXEC一样)


// //=>正则捕获还具备贪婪性，每一次匹配捕获的时候，
// //总是捕获到和正则匹配中最长的内容，
// //例如:    '2'   符合   \d+    '2018'也符合  \d+， 但是捕获的是最长的内容'2018'   ...
// let str = 'gibi2018laowang2019';
// let reg = /\d+?/g;  //把问号放到量词元字符的后面，代表的就不是出现零次或者一次了，而且取消捕获的贪婪性
// console.log(reg.exec(str));  // ['2']
// console.log(reg.exec(str));  // ['2']
// console.log(str.match(reg)) //['2']


// let str ='gibi2018laowang2019';
// let reg = /\d+/g;
// console.log(reg.lastIndex);   //索引从0开始
// console.log(reg.test(str));    // true  字符串中符合正则的标准显示true
// console.log(reg.lastIndex);  // 8 全局 第一次执行后 第二次开始的索引
// console.log(reg.exec(str));  //2019

// let str = 'gibi2018';    //数组
// let reg = / \d+/g;       //规则
// if (reg.test(str)){      //是否符合reg的规则，是则true，否则false
//     console.log(reg.exec(str));      //2018
// }


// let str = 'gibi2018';
// let reg = / \d+/g;
// console.log(reg.lastIndex); //索引从0开始
// console.log(reg.exec(str));  //2018
// console.log(reg.lastIndex);   // 8 全局 第一次执行后 第二次开始的索引8
// console.log(reg.exec('gibi2018laowang2019'));  //2019


//时间字符串格式化
// "2018/4/30 17:50:23" =>"04-30 17:50"
//简单处理
// let str = "2018/4/30 17:50;23",
//     ary = str.split(/(?:\/| |:)/g);
//     console.log(ary);
//     let [,month, day, hours, minutes] = ary;
//           result = `${month} ${day} ${hours} ${minutes} `;
//           console.log(result);

    

//     let str = "2018/4/30 17:50;23";
//     let ary = str.match(/\d+/g).map(item=>{
//         return item < 10 ? '0' + item : item;
//     });
// // => MAP相对于FOR-EACH来讲多了返回值，函数中RETURN的是啥，就是把当前数组中迭代的这一项替换成啥
// console.log(result);



// let str = 'laowang{val:2018}laowang{val:2019}',
//      reg= /\{val:(\d+)\}/g;
//      str = str.replace(reg,(...arg)=>{
//          console.log(arg);
//          return'AA';
//      })
// console.log(str);
//下

// // 时间字符串格式化
// String.prototype.myFormatTime =
// function (template='{0}年{1}月{2}日{3}时{4}分{5}秒'){
//      let ary = this.match(/\d+/g).map(item=>(item < 10 ? '0' +item:item ));
//      return template.replace(/\{(\d)\}/g,(...[, index])=>ary [index]  || '00');
     
// }
// let str = "2018-4-30";
// console.log(str.myFormatTime('{1}-{2} {3}:{4}')); //12-20 13:23

// //过滤
// window.onload = function (){
//     var oTxt1=document.getElementById('txt1');
//     var oTxt2=document.getElementById('txt2');
//     var oBtn = document.getElementById('btn');
    

//     oBtn.onclick=function(){
//         var re=/(草|滚|傻逼)|(<[^<>]+>)/g;
//         oTxt2.value=oTxt1.value.replace(re, '我你爹');
//     }
// }


// // 统计出现最多的字母和次数(两个方法)
//  var str ="aafbbcddddeeeAAABBCCCC"
//  //1.统计每个字母出现的次数 - 利用对象不重名的特征
//  //把每个恩字符作为属性名存入对象中，得出次数作为属性值
//  var obj = {};
//  for (var i=0;i<str.length;i++){
//      var cur = str.charAt(i);
//      if(obj[cur]){
//          obj[cur]++;//次数应该累加1 obj[cur] = obj[cur]+1
//      }else{//第一次
//          obj[cur] = 1;
//      }
//  }
// console.log(obj);
// //2.找出次数最多得字母
// //假设法
// var maxStr = ""; //出现最多的字母
// var max = 0;//出现最多的次数
// for(var key in obj){
//     //obj[key]次数
//     if(obj[key]>max){
//         max = obj[key];
//         maxStr = key;
//     }else if(obj[key]==max){
//         maxStr+=","+key;
//     }
// }
// console.log(maxStr,max);





var str  = "aafbbcddddeeebbcAAABBCCCC";
var ary = str.split("");
console.log(ary);
ary.sort(function(a,b){
    return a.localeCompare(b);
})
console.log(ary);
str = ary.join("");
var reg = /(\w)\1*/g; //匹配相同的字母
var maxStr ="";
var max =0;
str.replace(reg,function($0,$1){
    //$1 字母 $0.length 匹配字符出现的次数
    if($0.length>max){
           max = $0.length;
           maxStr = $1;
    }else if($0.length==max){
          maxStr+=","+$1;
    }
})
console.log(maxStr,max);

//排除法
//获取地址栏中的参数并放入对象中
var str = "http://www.baidu.com?id=557131028857&name=feicui&age=8#teacher=yang";
var reg = /([^?&#=]+)=([^?&#=]+)/g;
var obj ={};
str.replace(reg,function($1,$2){
    obj[$1]=$2;
})
console.log(obj);



    </script>
</body>
</html>